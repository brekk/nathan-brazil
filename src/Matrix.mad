import type { Either } from "Either"
import type { Maybe } from "Maybe"
import type { Random } from "Random"

import { Left, Right } from "Either"
import { always, equals } from "Function"
import List from "List"
import { abs, multiply } from "Math"
import { Just, Nothing, fromMaybe } from "Maybe"
import { float } from "Random"

import { aim2, aim3, aim4 } from "@/Aim"



export type MatrixError
  = DimensionsNotEqual
  | MustBeSquare
  | MustHaveSize(Integer)
  | InvalidCell(Integer, Integer)
  | GeneralError

export alias Matrix a = List (List a)

create :: Integer -> Integer -> a -> Matrix a
export create = (_rows, _cols, fill) => List.repeatWith(
  (_) => List.repeatWith(always(fill), _cols),
  _rows,
)



isSquare :: Matrix a -> Boolean
export isSquare = (matrix) => {
  x = List.length(matrix)
  return List.all(
    pipe(
      List.length,
      equals(x),
    ),
    matrix,
  )
}

rows :: Matrix a -> Integer
export rows = List.length

columns :: Matrix a -> Integer
export columns = (m) => pipe(
  List.nth(0),
  map(List.length),
  fromMaybe(0),
)(m)

// isRectangular :: Matrix a -> Boolean
// export isRectangular = (matrix) => rows(matrix) != columns(matrix)

getCell :: Integer -> Integer -> Matrix a -> Maybe a
export getCell = (rowIndex, index, matrix) => pipe(
  List.nth(rowIndex),
  chain(List.nth(index)),
)(matrix)

setCell :: Integer -> Integer -> a -> Matrix a -> Matrix a
export setCell = (rowIndex, index, f, matrix) => List.mapWithIndex(
  (row, x) => List.mapWithIndex(
    (cell, y) => if (rowIndex == x && index == y) {
      f
    } else {
      cell
    },
    row,
  ),
  matrix,
)

sameDimensions :: Matrix a -> Matrix a -> Boolean
export sameDimensions = (a, b) => {
  ax = rows(a)
  ay = columns(a)
  bx = rows(b)
  by = columns(b)
  return ax == bx && ay == by
}

multiMap :: (a -> b) -> Matrix a -> Matrix b
export multiMap = (fn, matrix) => map(map(fn), matrix)

combine :: (a -> a -> a) -> Matrix a -> Matrix a -> Either MatrixError (Matrix a)
export combine = (fn, matrixA, matrixB) => if (!sameDimensions(matrixA, matrixB)) {
  Left(DimensionsNotEqual)
} else {
  Right(
    List.mapWithIndex(
      (row, x) => List.mapWithIndex(
        (cell, y) => pipe(
          getCell(x, y),
          map((otherCell) => fn(cell, otherCell)),
          fromMaybe(cell),
        )(matrixB),
        row,
      ),
      matrixA,
    ),
  )
}

add :: Number a => Matrix a -> Matrix a -> Either MatrixError (Matrix a)
export add = combine((a, b) => a + b)

subtract :: Number a => Matrix a -> Matrix a -> Either MatrixError (Matrix a)
export subtract = combine((a, b) => a - b)

transposeWithDefault :: a -> Matrix a -> Matrix a
export transposeWithDefault = (def, matrix) => {
  r = rows(matrix)
  c = columns(matrix)
  return List.repeatWith(
    (y) => List.repeatWith(
      (x) => pipe(
        getCell(x, y),
        fromMaybe(def),
      )(matrix),
      r,
    ),
    c,
  )
}


determinantN1 :: Number a => Matrix a -> Either MatrixError a
export determinantN1 = (matrix) => if (!isSquare(matrix)) {
  Left(MustBeSquare)
} else if (rows(matrix) != 1) {
  Left(MustHaveSize(1))
} else {
  pipe(
    getCell(0, 0),
    where {
      Just(x) =>
        Right(x)

      Nothing =>
        Left(InvalidCell(0, 0))
    },
  )(matrix)
}

determinantN2 :: Number a => Matrix a -> Either MatrixError a
export determinantN2 = (matrix) => if (!isSquare(matrix)) {
  Left(MustBeSquare)
} else if (rows(matrix) != 2) {
  Left(MustHaveSize(2))
} else do {
  get = getCell($, $, matrix)
  return pipe(
    aim4((tl, br, tr, bl) => (tl * br) - (tr * bl), get(0, 0), get(1, 1), get(0, 1)),
    where {
      Just(x) =>
        Right(x)

      Nothing =>
        Left(GeneralError)
    },
  )(get(1, 0))
}

determinantN3Plus :: Number a => Matrix a -> Either MatrixError a
determinantN3Plus = (matrix) => {
  get = getCell($, $, matrix)
  n = rows(matrix)
  return pipe(
    List.range(0),
    List.reduce(
      (det, x) => pipe(
        List.reduce(
          (diag, y) => where(diag) {
            #[left, right] =>
              #[
                aim2(multiply, left, get(x, (y - x + n) % n)),
                aim2(multiply, right, get(x, (y + x) % n)),
              ]
          },
          #[get(0, x), get(0, x)],
        ),
        where {
          #[left, right] =>
            pipe(
              aim2((a, b) => a - b, left),
              map((f) => det - f),
            )(right)
        },
        0,
      )(List.range(1, x)),
      0,
    ),
    0,
  )(n)
}

determinant :: Number a => Matrix a -> Either MatrixError a
export determinant = (matrix) => if (!isSquare(matrix)) {
  Left(MustBeSquare)
} else do {
  n = rows(matrix)
  return if (n == 1) {
    determinantN1(matrix)
  } else if (n == 2) {
    determinantN2(matrix)
  } else {
    determinantN3Plus(matrix)
  }
}

// /*
// inUnitInterval :: Float -> Boolean
// export inUnitInterval = (f) => f >= 0 && f <= 1
// isProbabilisticRow :: List Float -> Boolean
// export isProbabilisticRow = (floats) => (
//   List.all(inUnitInterval, floats) && abs(List.reduce(add, 0, floats) - 1) < 0.0001
// )
// isProbabilistic :: Matrix -> Boolean
// export isProbabilistic = List.all(isProbabilisticRow)
// validate :: Matrix -> Boolean
// export validate = (m) => !List.isEmpty(m) && isProbabilistic(m) && isSquare(m)
// validateWithReason :: Matrix -> Maybe String
// export validateWithReason = (m) => if (List.isEmpty(m)) {
//   Just("Matrix cannot be empty")
// } else if (!isProbabilistic(m)) {
//   Just("Matrix must have rows which add up to 1")
// } else if (!isSquare(m)) {
//   Just("Matrix must be square")
// } else {
//   Nothing
// }
// create :: Matrix -> Either String Matrix
// export create = (m) => pipe(
//   validateWithReason,
//   map(Left),
//   fromMaybe(Right(m)),
// )(m)
// getRow :: Integer -> Matrix -> Maybe (List Float)
// export getRow = List.nth
// select :: Integer -> Float -> Matrix -> Maybe Integer
// export select = (rowIndex, f, m) => pipe(
//   getRow(rowIndex),
//   map(
//     pipe(
//       (row) => List.zip(List.range(0, List.length(row)), row),
//       List.reduce(
//         (stack, indexed) => where(indexed) {
//           #[index, x] =>
//             do {
//               sum = stack.sum + x
//               result = f <= sum ? index : stack.result
//               return { sum, result }
//             }
//         },
//         { sum: 0, result: 0 },
//       ),
//       .result,
//     ),
//   ),
// )(m)
// selectRow :: Random -> Integer -> Matrix -> Maybe Integer
// export selectRow = (r, i, m) => select(i, float(r), m)
// setRow :: Integer -> List Float -> Matrix -> Matrix
// export setRow = (rowIndex, newRow, matrix) => List.mapWithIndex(
//   (x, i) => i == rowIndex ? newRow : x,
//   matrix,
// )
// */
