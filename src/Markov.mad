import type { Either } from "Either"
import type { Maybe } from "Maybe"
import type { Random } from "Random"

import type { Stochastic } from "@/Matrix"
import type { IndexedHistogram } from "@/Stats"

import Dict from "Dictionary"
import { equals } from "Function"
import List from "List"
import { add } from "Math"
import { Just, Nothing, fromMaybe } from "Maybe"
import String from "String"

import { justGet } from "@/Dictionary"
import { mark } from "@/List"
import Matrix from "@/Matrix"
import { indexedHistogram } from "@/Stats"



export type MarkovError = NoValuesGiven | ValueSizeNotMatched | InvalidStateValue

export type MarkovChain a = MarkovChain(List a, Stochastic, Integer)

getValues :: MarkovChain a -> List a
export getValues = where {
  MarkovChain(v, _, _) =>
    v
}

getMatrix :: MarkovChain a -> Stochastic
export getMatrix = where {
  MarkovChain(_, m, _) =>
    m
}

getState :: MarkovChain a -> Integer
export getState = where {
  MarkovChain(_, _, i) =>
    i
}

/*
['a']
[[1]]

['a', 'b']
[
[0, 1],
[1, 0]
]

['a', 'b', 'c']
[
  [0, 1, 0],
  [0, 0, 1],
  [1, 0, 0]
]

['a', 'b', 'c', 'd']
[
  [0, 1, 0, 0],
  [0, 0, 1, 0],
  [0, 0, 0, 1],
  [1, 0, 0, 0],
]

['a', 'b', 'a']
[
  [0, 1, 0],
  [0.5, 0, 0.5],
  [1, 0, 0],
]
*/

invalidateWithReason :: MarkovChain a -> Maybe MarkovError
export invalidateWithReason = where {
  MarkovChain(v, probs, state) =>
    do {
      totalValues = List.length(v)
      return if (totalValues < 1) {
        Just(NoValuesGiven)
      } else if (Matrix.rows(probs) != totalValues) {
        Just(ValueSizeNotMatched)
      } else if (state > totalValues - 1) {
        Just(InvalidStateValue)
      } else {
        Nothing
      }
    }
}

empty :: {} -> MarkovChain a
export empty = () => MarkovChain([], [], 0)

current :: MarkovChain a -> Maybe a
export current = where {
  MarkovChain(values, _, i) =>
    List.nth(i, values)
}

isTerminal :: MarkovChain a -> Boolean
export isTerminal = where {
  MarkovChain(_, probs, i) =>
    pipe(
      List.nth(i),
      chain(List.nth(i)),
      map(equals(1.0)),
      fromMaybe(false),
    )(probs)
}

next :: Random -> MarkovChain a -> MarkovChain a
export next = (r, mc) => where(mc) {
  MarkovChain(values, probs, i) =>
    pipe(
      Matrix.selectFrom(r, i),
      fromMaybe(i),
      MarkovChain(values, probs),
    )(probs)
}

transform :: Random -> (Integer -> Integer -> Stochastic) -> MarkovChain a -> MarkovChain a
export transform = (r, fn, mc) => where(mc) {
  MarkovChain(values, probs, i) =>
    pipe(
      Matrix.selectFrom(r, i),
      fromMaybe(i),
      (v) => MarkovChain(values, fn(i, v), v),
    )(probs)
}

consumer :: Integer -> String -> IndexedHistogram String -> Stochastic -> Stochastic
export consumer = (i, str, hist, matrix) => where(#[List.nth(i, matrix), Dict.get(str, hist)]) {
  #[Just(row), Just(indices)] =>
    List.set(
      i,
      List.mapWithIndex(
        (x, index) => List.includes(index, map(add(1), indices)) ? 1 / List.length(indices) : x,
        row,
      ),
      matrix,
    )

  _ =>
    matrix
}

consume :: List String -> Stochastic
export consume = (strings) => {
  len = List.length(strings)
  hist = indexedHistogram(strings)
  return pipe(
    mark,
    List.reduce(
      (matrix, tuple) => where(tuple) {
        #[i, str] =>
          consumer(i, str, hist, matrix)
      },
      Matrix.createSequential(len),
    ),
  )(strings)
}
